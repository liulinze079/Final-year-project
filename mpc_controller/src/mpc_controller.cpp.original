// Calculate kernel
  std::vector<OSQPFloat> P_data;
  std::vector<OSQPInt> P_indices;
  std::vector<OSQPInt> P_indptr;
  int ind_P = 0;
  for (int col = 0; col < dim_u * m_; ++col)
  {
    P_indptr.push_back(ind_P);
    for (int row = 0; row <= col; ++row)
    {
      P_data.push_back(P(row, col));
      P_indices.push_back(row);
      ind_P++;
    }
  }
  P_indptr.push_back(ind_P);

  // Calculate affine constraints (4m x 2m)
  std::vector<OSQPFloat> A_data;
  std::vector<OSQPInt> A_indices;
  std::vector<OSQPInt> A_indptr;
  int ind_A = 0;
  A_indptr.push_back(ind_A);
  for (int j = 0; j < m_; ++j)
  {
    for (int n = 0; n < dim_u; ++n)
    {
      for (int row = dim_u * j + n; row < dim_u * m_; row += dim_u)
      {
        A_data.push_back(1.0);
        A_indices.push_back(row);
        ++ind_A;
      }
      A_data.push_back(1.0);
      A_indices.push_back(dim_u * m_ + dim_u * j + n);
      ++ind_A;
      A_indptr.push_back(ind_A);
    }
  }

  // Calculate offset
  std::vector<OSQPFloat> q_data;
  for (int row = 0; row < dim_u * m_; ++row)
  {
    q_data.push_back(q(row, 0));
  }

  // Calculate constraints
  std::vector<OSQPFloat> lower_bounds;
  std::vector<OSQPFloat> upper_bounds;
  for (int row = 0; row < 2 * dim_u * m_; row++)
  {
    lower_bounds.push_back(lower(row, 0));
    upper_bounds.push_back(upper(row, 0));
  }

  // Create the OSQP solver
  OSQPSolver *solver = osqp_create();
  
  // Define the problem data
  OSQPInt m = 2 * dim_u * m_;  // Number of constraints
  OSQPInt n = dim_u * m_;      // Number of variables
  
  // Convert Eigen data to C arrays
  OSQPCscMatrix* P_csc = (OSQPCscMatrix*)malloc(sizeof(OSQPCscMatrix));
  P_csc->m = n;
  P_csc->n = n;
  P_csc->nz = P_data.size();
  P_csc->nzmax = P_data.size();
  P_csc->x = P_data.data();
  P_csc->i = P_indices.data();
  P_csc->p = P_indptr.data();
  
  OSQPCscMatrix* A_csc = (OSQPCscMatrix*)malloc(sizeof(OSQPCscMatrix));
  A_csc->m = m;
  A_csc->n = n;
  A_csc->nz = A_data.size();
  A_csc->nzmax = A_data.size();
  A_csc->x = A_data.data();
  A_csc->i = A_indices.data();
  A_csc->p = A_indptr.data();
  
  // Set solver settings
  OSQPSettings *settings = (OSQPSettings *)malloc(sizeof(OSQPSettings));
  osqp_set_default_settings(settings);
  settings->verbose = false;
  settings->warm_starting = true;  // Note: renamed from warm_start to warm_starting
  
  // Set up the solver
  OSQPInt exitflag = osqp_setup(&solver, P_csc, q.data(), A_csc, lower_bounds.data(), upper_bounds.data(), m, n, settings);
  
  // Solve the problem
  OSQPInt status = osqp_solve(solver);
  
  Eigen::Vector2d u;
  if (status == OSQP_SOLVED) {
    // Get the solution
    const OSQPSolution* solution = osqp_get_solution(solver);
    u = Eigen::Vector2d(solution->x[0] + du_p[0] + u_r[0], 
                         regularizeAngle(solution->x[1] + du_p[1] + u_r[1]));
  } else {
    // If not solved, return zero control
    std::cout << "OSQP failed with status: " << osqp_status_string(status) << std::endl;
    u = Eigen::Vector2d::Zero();
  }
  
  // Clean up
  osqp_cleanup(solver);
  free(P_csc);
  free(A_csc);
  free(settings);
  
  return u;
